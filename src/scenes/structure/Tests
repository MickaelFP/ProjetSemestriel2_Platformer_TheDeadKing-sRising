   
   
   
   
    //***************** retenir les coordonnées du joueur *****************//
    
    /*
    create()
    {
        var direction = 'right';
    }

    
    update()
    {
        if (cursors.left.isDown) {
            player.direction = 'left';
            player.setVelocityX(-160);
            player.anims.play('left', true);
        }
        else if (cursors.right.isDown) {
            player.direction = 'right';
            player.setVelocityX(160);
            player.anims.play('right', true);
        }
    }    
    */

    //*********************************************************************//



    //***************** essaies de lumières *****************//

    /*
        var dummy = this.add.image(900, 400, 'light').setVisible(false);

        var light1 = this.lights.addLight(280, 400, 200);
        var ellipse1 = new Phaser.Geom.Ellipse(light1.x, light1.y, 70, 100);
    
        var light2 = this.lights.addLight(650, 386, 200);
        var ellipse2 = new Phaser.Geom.Ellipse(light2.x, light2.y, 30, 40);
    
        var light3 = this.lights.addLight(900, 400, 200);

        this.time.addEvent({
            delay: 100,
            callback: function ()
            {
                Phaser.Geom.Ellipse.Random(ellipse1, light1);
                Phaser.Geom.Ellipse.Random(ellipse2, light2);
            },
            callbackScope: this,
            repeat: -1
        });

        this.tweens.add({
            targets: [ light3, dummy ],
            y: 150,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1,
            duration: 3000
        });

        // We must enable the light system. By default is disabled
        this.lights.enable();

    //*********************************************************************//




    //*************** Move monstres en focntion du joueur ******************//

            /**
     * Quand on dépasse un monstre
     * il se tourne vers nous
     * @param {Player} player
     * @param {Phaser.Physics.Arcade.Sprite} monster
     *//*
    monsterMove(player, monster)
    {
        let me = this;
        me.player.body.velocity.x = player.VelocityX;
        me.monster.body.velocity.x = monster.VelocityX;

        //if (player.x < monster.x && monster.setVelocityX == player.setVelocityX)        
        if (player.x < monster.x && player.VelocityX > 0)
        {
            if(monster.VelocityX <= 0)
            {
                monster.flipX = false;
            }
            else
            {
                monster.flipX = true;
                monster.setVelocityX = - monster.VelocityX;//-100;
            }
        } 
        else if (player.x < monster.x && player.VelocityX < 0)
        {
            if(monster.VelocityX < 0)
            {
                monster.flipX = false;
            }
            else
            {
                monster.flipX = true;
                monster.setVelocityX = - monster.VelocityX;//-100;
            }
        }
        else if (player.x > monster.x && player.VelocityX > 0)
        {
            if(monster.VelocityX > 0)
            {
                monster.flipX = false;
            }
            else
            {
                monster.flipX = true;
                monster.setVelocityX = - monster.VelocityX;//-100;
            }
        }
        else if (player.x > monster.x && player.VelocityX < 0)
        {
            if(monster.VelocityX > 0)
            {
                monster.flipX = false;
            }
            else
            {
                monster.flipX = true;
                monster.setVelocityX = - monster.VelocityX;//-100;
            }
        }
        else
        {
            monster.flipX = false;
        }                    
    }*/

    //*********************************************************************//





    //*************** casser les monstre immobile sans mourrir à leur contact ******************//

    /*
    vaseBroke() // update
    {
        
        let me=this;
        let broke=this.add.sprite(this.sys.canvas.width/2,this.sys.canvas.height/2,"broke")
        broke.displayWidth=32;
        broke.displayHeight=32;
        //broke.visible=false
        broke.visible=true;
        broke.rotation = Phaser.Math.Between(0,6);
        broke.x=this.x; //object.x
        broke.y=this.y; //object.Y
    } // FIN DE VASEBROKE

    hitVase(player){
        let me=this;
        if(me.disableBody !== true/*,true*/){ //si notre vase n'est pas déjà détruit
            if(
                // si le player descend
                player.body.velocity.y > 0
                // et si le bas du player est plus haut que le monstre
                && player.getBounds().bottom < me.getBounds().top+30
    
            ){
                ui.gagne();
                me.isDead=true; //ok le monstre est mort
                me.disableBody(true,true);//plus de collisions
                me.vaseBroke(monster,function(){
                    //à la fin de la petite anim...ben il se passe rien :)
                })
                //petit son de mort du monstre
                
                /*
                me.music = this.sound.add('broke');
    
                var musicConfig = 
                {
                    mute: false,
                    volume: 0.3,
                    rate : 1,
                    detune: 0,
                    seek: 0,
                    loop: false,
                    delay:0,
                }
                me.music.play(musicConfig);
                */

                //notre joueur rebondit sur le monstre
                //player.directionY=500;
            }
    
        }
    }

    /*
    creat(object)
    {
        this.broke=this.add.sprite(this.sys.canvas.width/2,this.sys.canvas.height/2,"broke")
        this.broke.displayWidth=32;
        this.broke.displayHeight=32;
        this.broke.visible=false
    }
    */

    /*
    //let vaseContainer=this.add.container();
    this.vaseObjects = this.map.getObjectLayer('vase')['objects'];
    this.vaseObjects.forEach(monsterObject => {
        let monster=new MonsterVase(this,monsterObject.x,monsterObject.y-26);
        monstersContainer.add(monster);
        this.physics.add.collider(monster, this.solides); //vase
        //this.physics.add.collider(monster, this.player); //vase
    });*//*

    if(this.vaseObjects.isDead != true)
    {
        if(
            // si le player descend
            player.body.velocity.y > 0
            // et si le bas du player est plus haut que le monstre
            && player.getBounds().bottom < this.vaseObjects.getBounds().top+30
        ){
            let broke=this.add.sprite(this.sys.canvas.width/2,this.sys.canvas.height/2,"broke")
            ui.gagne();
            this.vaseObjects.isDead=true; //ok le monstre est mort
            this.vaseObjects.disableBody(true,true);//plus de collisions
        }
    }*/


    //*********************************************************************//




    //*************** Pour detruire le projectile (pas concluant) ******************//


                /*while(!this.destroyProjectil)
            {
                this.time.addEvent
                ({
                    delay: 500,
                    callback: ()=>
                    {
                        this.destroyProjectil = true;
                        console.log("DEBUG DEBUG DEBUG");
                        //this.aPressed.destroy();
                        //this.aPressed.visible(false);
                        //this.aPressed.disableBody(true, true);
                        //this.setVelocity(0,0);

                    },
                    loop: false
                })
                while(this.destroyProjectil)
                {
                    this.aPressed.destroy();
                    //this.aPressed.visible(false);
                    //this.aPressed.disableBody(true, true);
                    this.destroyProjectil = false;
                    console.log("DEBUG DEBUG DEBUG destroyProjectil");
                    return;
                }
                return;

            }*/

            
    //*********************************************************************//



        /**
     * Tue le player
     * - le rend invisible
     * - fait apparaitre du sang
     * - ressuscite le player
     * - redémarre le tableau
     */  /*
    playerDie(player,hp)
    {
        let me=this;
        if(!me.player.isDead) 
        {
            ui.perdre1();
            ui.losePV();
            if(this.hp != 0)
            {
                me.saignePlayer(me.player, function () 
                {
                    //à la fin de la petite anim, on relance le jeu
                    me.blood2.visible = false;
                    me.player.anims.play('turn');
                    //player.directionX= -100;
                    //me.scene.restart();
                })
            }
            else
            {
                me.player.isDead = true;
                me.player.visible = false;
                //ça saigne...
                me.saignePlayer(me.player, function () 
                {
                    //à la fin de la petite anim, on relance le jeu
                    me.blood2.visible = false;
                    me.player.anims.play('turn');
                    me.player.isDead = false;
                    me.scene.restart();
                })
                this.music = this.sound.add('crack');
    
                var musicConfig = 
                {
                    mute: false,
                    volume: 0.3,
                    rate : 1,
                    detune: 0,
                    seek: 0,
                    loop: false,
                    delay:0,
                }
                this.music.play(musicConfig);
    
                localStorage.removeItem("bougie");
            }

        }
    }*/




    // ********************************* Tentative de déplacement d'un monstre en fonction des coordonées du joueur *********************************
    //
    /**
     * Quand on dépasse un monstre
     * il se tourne vers nous
     * @param {Player} player
     * @param {Phaser.Physics.Arcade.Sprite} monster
     *//*
    monsterMove(player, monster)
    {       
        //let me=this;
        this.player.body.position.x = playerX;
        this.player.position.x = playerX;
        this.player.x = playerX;
        this.monster.body.position.x = monsterX;
        this.monster.position.x = monsterX;
        this.monster.x = monsterX;

        if (playerX < monsterX)
        {
            if(monster.VelocityX < 0)
            {
                monster.flipX = true;
                monster.setVelocityX = -100;
            }
            else
            {
                monster.flipX = true;
                monster.setVelocityX = -100;//-100;
            }
        } 
        else if (playerX > monsterX)
        {
            if(monster.VelocityX > 0)
            {
                monster.flipX = false;
                monster.setVelocityX = 100;
            }
            else
            {
                monster.flipX = true;
                monster.setVelocityX = 100;//-100;
            }
        }
    }*/



//**************************************** monster with tween ***********************

        //définir les propriété que l'on va utiliser dans notre animation

        // X
        /*this.originalX=x;
        this.minX=x-200;
        this.maxX=x+200;

        // Y
        this.originalY=y;
        this.minY=y-5;
        this.maxY=y+5;

        // on applique les propriétés du début de l'animation
        this.x=this.minX;
        this.y=this.minY;
        this.alpha=0;
        let me=this;

        //on fait apparaitre notre objet avec un petit delay, puis on lance l'animation
        //ceci a pour effet de décaler les animations pour ce même objet
        scene.tweens.add({
                targets:this,
                duration:200,
                delay:Math.random()*1000,
                alpha:{
                    startDelay:Math.random()*5000,
                    from:0,
                    to:1,
                },
                onComplete: function () {
                    me.start();
                }
        })*/


    /*start(){
        this.scene.tweens.add({
            targets: this,
            x: {
                from: this.minX,
                to:this.maxX,
                duration: 10*1000,
                ease: 'Sine.easeInOut',
                yoyo: -1,
                repeat:-1,
                flipX:false,
            },
            y: {
                from: this.minY,
                to:this.maxY,
                duration: 500,
                ease: 'Sine.easeInOut',
                yoyo: -1,
                repeat:-1
            }
        });
    }*/