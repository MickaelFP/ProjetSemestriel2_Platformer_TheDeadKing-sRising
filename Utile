
        //------------------------------------------------ Effet sur la lave (ou autre surface mortelle) ------------------------------------------------

        /*this.laveFxContainer=this.add.container();
        this.lave.forEachTile(function(tile){ //on boucle sur TOUTES les tiles de lave pour générer des particules
            if(tile.index !== -1){ //uniquement pour les tiles remplies

                /*
                //dé-commenter pour mieux comprendre ce qui se passe
                console.log("lave tile",tile.index,tile);
                let g=ici.add.graphics();
                laveFxContainer.add(g);
                g.setPosition(tile.pixelX,tile.pixelY)
                g.lineStyle(1,0xFF0000);
                g.strokeRect(0, 0, 64, 64);
                */

            /*    //on va créer des particules
                let props={
                    frame: [
                        //'star', //pour afficher aussi des étoiles
                        'death-white'
                    ],
                    frequency:200,
                    lifespan: 2000,
                    quantity:2,
                    x:{min:-32,max:32},
                    y:{min:-12,max:52},
                    tint:[  0xC11A05,0x883333,0xBB5500,0xFF7F27 ],
                    rotate: {min:-10,max:10},
                    speedX: { min: -10, max: 10 },
                    speedY: { min: -20, max: -30 },
                    scale: {start: 0, end: 1},
                    alpha: { start: 1, end: 0 },
                    blendMode: Phaser.BlendModes.ADD,
                };
                let props2={...props}; //copie props sans props 2
                props2.blendMode=Phaser.BlendModes.MULTIPLY; // un autre blend mode plus sombre

                //ok tout est prêt...ajoute notre objet graphique
                let laveParticles = ici.add.particles('particles');

                //ajoute le premier émetteur de particules
                laveParticles.createEmitter(props);
                //on ne va pas ajouter le second effet émetteur mobile car il consomme trop de ressources
                if(!ici.isMobile) {
                    laveParticles.createEmitter(props2); // ajoute le second
                }
                // positionne le tout au niveau de la tile
                laveParticles.x=tile.pixelX+32;
                laveParticles.y=tile.pixelY+32;
                ici.laveFxContainer.add(laveParticles);

                //optimisation (les particules sont invisibles et désactivées par défaut)
                //elles seront activées via update() et optimizeDisplay()
                laveParticles.pause();
                laveParticles.visible=false;
                //on définit un rectangle pour notre tile de particules qui nous servira plus tard
                laveParticles.rectangle=new Phaser.Geom.Rectangle(tile.pixelX,tile.pixelY,64,64);

            }

        })*/
        
//******************************************



/*
    agir(player, rayon) {
        //let me = this,
        //console.log("grrrrrr");
        // si l'this.corp est dans un rayon de 'rayon' pixel autour du personnage
        if (Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2)) < this.rayon) {
            if (player.x - this.x < -40) {    // si player est à gauche de this.corp
                this.setVelocityX(-this.vitesse);    //    this.corp va vers la gauche
            } else if (player.x - this.x > 40) {        // si player est à droite de this.corp
                this.setVelocityX(this.vitesse);    //    this.corp va vers la droite
            } else {
                this.setVelocityX(0);    // sinon this.corp reste immobile
            }
        } else {
            this.setVelocityX(0);    // sinon this.corp reste immobile
        }
    }
*/



/*

    // Ennemy kill Player
    if ((this.body.touching.right && (this.world.player.body.touching.right || this.world.player.body.touching.left))
    || (this.body.touching.left && (this.world.player.body.touching.right || this.world.player.body.touching.left))
    && this.isAlive)
    {
        this.world.restart();
    }
*/

//******************************************


//******************* ANIMATION SYMPA ***********************

//this.load.spritesheet('imageKey', 'assets/image.png', { frameWidth: 206, frameHeight: 184 } );
/*
        this.anims.create({
            key: 'keyActivation',
            frames: this.anims.generateFrameNumbers('imageKey', { start: 0, end: 50 }),
            frameRate: 30,
            repeat: -1
        });
*/

        /*
        this.input.keyboard.on('keydown-A', function () 
        {
            this.a.play({volume:.5});
            this.add.sprite(Math.random()*game.config.width, Math.random()*game.config.height, 'imageKey')
            .play('keyActivation', true);
        }, this);*/

//******************************************


//******************* DE LA PHYSIQUE D'ATTRACTION ***********************

    /*
    width: 800,
    height: 600,
    backgroundColor: '#000000',
    parent: 'phaser-example',
    physics: {
                default: 'matter',
                matter: {
                    gravity: {
                        scale: 0
                    },
                    plugins: {
                        attractors: true
                    }
                }
            },
            scene: {
                preload: preload,
                create: create
            }
     };
        
        var game = new Phaser.Game(config);
        */

        //this.arcade.enableAttractorPlugin();

        //this.arcade.world.setBounds();
        /*
        this.sun = this.add.image(400, 200, 'sun', null, {
            shape: {
                type: 'circle',
                radius: 64
            },
            plugin: {
                attractors: [
                    function (bodyA, bodyB) {
                        return {
                            x: (bodyA.position.x - bodyB.position.x) * 0.000001,
                            y: (bodyA.position.y - bodyB.position.y) * 0.000001
                        };
                    }
                ]
            }
        });*/

    //this.arcade.add.mouseSpring();
//******************************************


//******************* Infos & Liens ***********************

    /**
     * Ce tableau démontre comment se servir de Tiled, un petit logiciel qui permet de designer des levels et de les importer dans Phaser (entre autre).
     *
     * Ce qui suit est très fortement inspiré de ce tuto :
     * https://stackabuse.com/phaser-3-and-tiled-building-a-platformer/
     *
     * Tuto qui propose quelques alternatives (la manière dont son découpées certaines maisons notamment) :
     * https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6
     */

//******************************************

        /*
        this.input.keyboard.on('keydown-A', function () 
        {
            this.a.play({volume:.5});
            this.add.sprite(Math.random()*game.config.width, Math.random()*game.config.height, 'cp').play('spin', true);
        }, this);*/


//****************** Deplacement ***********************

        if(this.body)
        {
            /*
            if(this.body.velocity.x < -240)
            {
                this.setVelocityX(-80*(Math.random()+1.5));
                this.flipX=true;
            }
            else if(this.body.velocity.x < 0 & this.body.velocity.x >= -240)
            {
                this.flipX=true;
            }
            else if(this.body.velocity.x > 0 & this.body.velocity.x <= 240)
            {
                this.flipX=false;
            }
            else if(this.body.velocity.x > 240)
            {
                this.setVelocityX(80*(Math.random()+1.5));
                this.flipX=false;
            }
            else
            {
                this.flipX=false;
            }
            */
        }

//***

        if(this.body)
        {
            if(this.monster.body.velocity.x < 0 & this.player.x < this.monster.body.x)
            {
                me.monster.flipX=true;
            }
            else if(this.monster.body.velocity.x < 0 & this.player.x > this.monster.body.x)
            {
                me.monster.setVelocityX(200);
                me.monster.flipX=false;
            }

            else if(this.monster.body.velocity.x > 0 & this.player.x < this.monster.body.x)
            {
                me.monster.setVelocityX(-200);
                me.monster.flipX=true;
            }
            else if(this.monster.body.velocity.x > 0 & this.player.x > this.monster.body.x)
            {
                me.monster.flipX=false;
            }

            /*else if(this.monster.body.velocity.x = 0 & this.player.x < this.monster.body.x)
            {
                me.monster.setVelocityX(-200);
                me.monster.flipX=true;
            }
            else if(this.monster.body.velocity.x = 0 & this.player.x > this.monster.body.x)
            {
                me.monster.setVelocityX(200);
                me.monster.flipX=false;
            }*/
            /*else if(){}*/
            else
            {
                //me.setVelocityX(0);
                me.monster.flipX=false;
            }

//***

        /*if(this.body.velocity.x > 240)
        {
            this.setVelocityX(240);
        }
        else if (this.velocityX < 80)
        {
            this.setVelocityX(120);
        }*/

//******************************************


//****************** Random ***********************

    this.rnd = Phaser.Math.RND;
    this.rnd = new Phaser.Math.RandomDataGenerator((Date.now() * Math.random()).toString());
    this.value = this.rnd.integerInRange(0, 3);





//****************** Tween - monster moving animation ***********************

       // X
        this.originalX=x;
        this.minX=x-200;
        this.maxX=x+200;

        // Y
        this.originalY=y;
        this.minY=y-5;
        this.maxY=y+5;

        // on applique les propriétés du début de l'animation
        this.x=this.minX;
        this.y=this.minY;
        this.alpha=0;
        let me=this;

        //on fait apparaitre notre objet avec un petit delay, puis on lance l'animation
        //ceci a pour effet de décaler les animations pour ce même objet
        scene.tweens.add({
                targets:this,
                duration:200,
                delay:Math.random()*1000,
                alpha:{
                    startDelay:Math.random()*5000,
                    from:0,
                    to:1,
                },
                onComplete: function () {
                    me.start();
                }
            })

    }

    start(){
        this.scene.tweens.add({
            targets: this,
            x: {
                from: this.minX,
                to:this.maxX,
                duration: 10*1000,
                ease: 'Sine.easeInOut',
                yoyo: -1,
                repeat:-1,
                flipX:true,
            },
            y: {
                from: this.minY,
                to:this.maxY,
                duration: 500,
                ease: 'Sine.easeInOut',
                yoyo: -1,
                repeat:-1
            }
        });
    }

//******************************************





//****************** Invincible / Vulnérable ***********************

        /*this.player.body.enable = false;
        this.time.addEvent({
            delay: 4000,
            callback: ()=>{
                this.player.body.enable = true;
                console.log("vulnerable");
            },
            loop: false
        })*/
    }

    /*vulnerable(){
        console.log("vulnerable");
        this.invicibleForEver = false;
    }*/

//******************************************