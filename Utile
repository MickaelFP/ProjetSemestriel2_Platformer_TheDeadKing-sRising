/*
    agir(player, rayon) {
        //let me = this,
        //console.log("grrrrrr");
        // si l'this.corp est dans un rayon de 'rayon' pixel autour du personnage
        if (Math.sqrt(Math.pow(player.x - this.x, 2) + Math.pow(player.y - this.y, 2)) < this.rayon) {
            if (player.x - this.x < -40) {    // si player est à gauche de this.corp
                this.setVelocityX(-this.vitesse);    //    this.corp va vers la gauche
            } else if (player.x - this.x > 40) {        // si player est à droite de this.corp
                this.setVelocityX(this.vitesse);    //    this.corp va vers la droite
            } else {
                this.setVelocityX(0);    // sinon this.corp reste immobile
            }
        } else {
            this.setVelocityX(0);    // sinon this.corp reste immobile
        }
    }
*/



/*

    // Ennemy kill Player
    if ((this.body.touching.right && (this.world.player.body.touching.right || this.world.player.body.touching.left))
    || (this.body.touching.left && (this.world.player.body.touching.right || this.world.player.body.touching.left))
    && this.isAlive)
    {
        this.world.restart();
    }
*/

//******************************************


//******************* ANIMATION SYMPA ***********************

//this.load.spritesheet('imageKey', 'assets/image.png', { frameWidth: 206, frameHeight: 184 } );
/*
        this.anims.create({
            key: 'keyActivation',
            frames: this.anims.generateFrameNumbers('imageKey', { start: 0, end: 50 }),
            frameRate: 30,
            repeat: -1
        });
*/

        /*
        this.input.keyboard.on('keydown-A', function () 
        {
            this.a.play({volume:.5});
            this.add.sprite(Math.random()*game.config.width, Math.random()*game.config.height, 'imageKey')
            .play('keyActivation', true);
        }, this);*/

//******************************************


//******************* DE LA PHYSIQUE D'ATTRACTION ***********************

    /*
    width: 800,
    height: 600,
    backgroundColor: '#000000',
    parent: 'phaser-example',
    physics: {
                default: 'matter',
                matter: {
                    gravity: {
                        scale: 0
                    },
                    plugins: {
                        attractors: true
                    }
                }
            },
            scene: {
                preload: preload,
                create: create
            }
     };
        
        var game = new Phaser.Game(config);
        */

        //this.arcade.enableAttractorPlugin();

        //this.arcade.world.setBounds();
        /*
        this.sun = this.add.image(400, 200, 'sun', null, {
            shape: {
                type: 'circle',
                radius: 64
            },
            plugin: {
                attractors: [
                    function (bodyA, bodyB) {
                        return {
                            x: (bodyA.position.x - bodyB.position.x) * 0.000001,
                            y: (bodyA.position.y - bodyB.position.y) * 0.000001
                        };
                    }
                ]
            }
        });*/

    //this.arcade.add.mouseSpring();
//******************************************


//******************* Infos & Liens ***********************

    /**
     * Ce tableau démontre comment se servir de Tiled, un petit logiciel qui permet de designer des levels et de les importer dans Phaser (entre autre).
     *
     * Ce qui suit est très fortement inspiré de ce tuto :
     * https://stackabuse.com/phaser-3-and-tiled-building-a-platformer/
     *
     * Tuto qui propose quelques alternatives (la manière dont son découpées certaines maisons notamment) :
     * https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6
     */

//******************************************

        /*
        this.input.keyboard.on('keydown-A', function () 
        {
            this.a.play({volume:.5});
            this.add.sprite(Math.random()*game.config.width, Math.random()*game.config.height, 'cp').play('spin', true);
        }, this);*/


//****************** Deplacement ***********************

        if(this.body)
        {
            /*
            if(this.body.velocity.x < -240)
            {
                this.setVelocityX(-80*(Math.random()+1.5));
                this.flipX=true;
            }
            else if(this.body.velocity.x < 0 & this.body.velocity.x >= -240)
            {
                this.flipX=true;
            }
            else if(this.body.velocity.x > 0 & this.body.velocity.x <= 240)
            {
                this.flipX=false;
            }
            else if(this.body.velocity.x > 240)
            {
                this.setVelocityX(80*(Math.random()+1.5));
                this.flipX=false;
            }
            else
            {
                this.flipX=false;
            }
            */
        }

//***

        if(this.body)
        {
            if(this.monster.body.velocity.x < 0 & this.player.x < this.monster.body.x)
            {
                me.monster.flipX=true;
            }
            else if(this.monster.body.velocity.x < 0 & this.player.x > this.monster.body.x)
            {
                me.monster.setVelocityX(200);
                me.monster.flipX=false;
            }

            else if(this.monster.body.velocity.x > 0 & this.player.x < this.monster.body.x)
            {
                me.monster.setVelocityX(-200);
                me.monster.flipX=true;
            }
            else if(this.monster.body.velocity.x > 0 & this.player.x > this.monster.body.x)
            {
                me.monster.flipX=false;
            }

            /*else if(this.monster.body.velocity.x = 0 & this.player.x < this.monster.body.x)
            {
                me.monster.setVelocityX(-200);
                me.monster.flipX=true;
            }
            else if(this.monster.body.velocity.x = 0 & this.player.x > this.monster.body.x)
            {
                me.monster.setVelocityX(200);
                me.monster.flipX=false;
            }*/
            /*else if(){}*/
            else
            {
                //me.setVelocityX(0);
                me.monster.flipX=false;
            }

//***

        /*if(this.body.velocity.x > 240)
        {
            this.setVelocityX(240);
        }
        else if (this.velocityX < 80)
        {
            this.setVelocityX(120);
        }*/

//******************************************


//****************** Random ***********************

    this.rnd = Phaser.Math.RND;
    this.rnd = new Phaser.Math.RandomDataGenerator((Date.now() * Math.random()).toString());
    this.value = this.rnd.integerInRange(0, 3);





//****************** Tween - monster moving animation ***********************

       // X
        this.originalX=x;
        this.minX=x-200;
        this.maxX=x+200;

        // Y
        this.originalY=y;
        this.minY=y-5;
        this.maxY=y+5;

        // on applique les propriétés du début de l'animation
        this.x=this.minX;
        this.y=this.minY;
        this.alpha=0;
        let me=this;

        //on fait apparaitre notre objet avec un petit delay, puis on lance l'animation
        //ceci a pour effet de décaler les animations pour ce même objet
        scene.tweens.add({
                targets:this,
                duration:200,
                delay:Math.random()*1000,
                alpha:{
                    startDelay:Math.random()*5000,
                    from:0,
                    to:1,
                },
                onComplete: function () {
                    me.start();
                }
            })

    }

    start(){
        this.scene.tweens.add({
            targets: this,
            x: {
                from: this.minX,
                to:this.maxX,
                duration: 10*1000,
                ease: 'Sine.easeInOut',
                yoyo: -1,
                repeat:-1,
                flipX:true,
            },
            y: {
                from: this.minY,
                to:this.maxY,
                duration: 500,
                ease: 'Sine.easeInOut',
                yoyo: -1,
                repeat:-1
            }
        });
    }
//******************************************